#!/usr/bin/env bash
#
# ARG_POSITIONAL_INF([commands],["$'\nclean: Remove the virtualenv\ninit: Install the dependencies in the virtualenv\ntest: Run the tests\nlint: Run the linter\npackage: Package the source code and its dependencies into a zip file'"],[1])
# ARG_OPTIONAL_SINGLE([project],[p],[Project path (default is current path)],["."])
# ARG_OPTIONAL_BOOLEAN([dev],[d],['init' command should install development dependencies as well (default off)])
# ARG_OPTIONAL_BOOLEAN([report],[r],[generate reports (applies only to 'test' and 'lint' commands, default off)])
# ARG_OPTIONAL_BOOLEAN([errors],[e],[lint errors only (default off)])
# ARG_OPTIONAL_SINGLE([tests-selector],[],['test' command will be applied using the provided tests-selector])
# ARG_OPTIONAL_SINGLE([test-report],[],[test report file path (default test-report-xml)],["test-report.xml"])
# ARG_OPTIONAL_SINGLE([lint-config],[],[lint config file path (default .pylintrc)],[".pylintrc"])
# ARG_OPTIONAL_SINGLE([lint-report],[],[lint report file path (default pylint.log)],["pylint.log"])
# ARG_OPTIONAL_SINGLE([package-name],[z],[package zip file name (defaults to project directory name)])
# ARG_OPTIONAL_SINGLE([package-target],[t],[package target file path (default /tmp)],['/tmp'])
# ARG_HELP([Welcome to pybt, an opinionated Python build tool (backed by pipenv)])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='pdrezth'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_commands=('' )
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_project="."
_arg_dev="off"
_arg_report="off"
_arg_errors="off"
_arg_tests_selector=
_arg_test_report="test-report.xml"
_arg_lint_config=".pylintrc"
_arg_lint_report="pylint.log"
_arg_package_name=
_arg_package_target='/tmp'

print_help ()
{
	printf '%s\n' "Welcome to pybt, an opinionated Python build tool (backed by pipenv)"
	printf 'Usage: %s [-p|--project <arg>] [-d|--(no-)dev] [-r|--(no-)report] [-e|--(no-)errors] [--tests-selector <arg>] [--test-report <arg>] [--lint-config <arg>] [--lint-report <arg>] [-z|--package-name <arg>] [-t|--package-target <arg>] [-h|--help] <commands-1> [<commands-2>] ... [<commands-n>] ...\n' "$0"
	printf '\t%s\n' "<commands>: "$'
		clean: Remove the virtualenv
		init: Install the dependencies in the virtualenv
		test: Run the tests
		lint: Run the linter
		package: Package the source code and its dependencies into a zip file'""
	printf '\t%s\n' "-p,--project: Project path (default is current path) (default: '"."')"
	printf '\t%s\n' "-d,--dev,--no-dev: 'init' command should install development dependencies as well (default off) (off by default)"
	printf '\t%s\n' "-r,--report,--no-report: generate reports (applies only to 'test' and 'lint' commands, default off) (off by default)"
	printf '\t%s\n' "-e,--errors,--no-errors: lint errors only (default off) (off by default)"
	printf '\t%s\n' "--tests-selector: 'test' command will be applied using the provided tests-selector (no default)"
	printf '\t%s\n' "--test-report: test report file path (default test-report-xml) (default: '"test-report.xml"')"
	printf '\t%s\n' "--lint-config: lint config file path (default .pylintrc) (default: '".pylintrc"')"
	printf '\t%s\n' "--lint-report: lint report file path (default pylint.log) (default: '"pylint.log"')"
	printf '\t%s\n' "-z,--package-name: package zip file name (defaults to project directory name) (no default)"
	printf '\t%s\n' "-t,--package-target: package target file path (default /tmp) (default: ''/tmp'')"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-p|--project)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_project="$2"
				shift
				;;
			--project=*)
				_arg_project="${_key##--project=}"
				;;
			-p*)
				_arg_project="${_key##-p}"
				;;
			-d|--no-dev|--dev)
				_arg_dev="on"
				test "${1:0:5}" = "--no-" && _arg_dev="off"
				;;
			-d*)
				_arg_dev="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-r|--no-report|--report)
				_arg_report="on"
				test "${1:0:5}" = "--no-" && _arg_report="off"
				;;
			-r*)
				_arg_report="on"
				_next="${_key##-r}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-e|--no-errors|--errors)
				_arg_errors="on"
				test "${1:0:5}" = "--no-" && _arg_errors="off"
				;;
			-e*)
				_arg_errors="on"
				_next="${_key##-e}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-e" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--tests-selector)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_tests_selector="$2"
				shift
				;;
			--tests-selector=*)
				_arg_tests_selector="${_key##--tests-selector=}"
				;;
			--test-report)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_test_report="$2"
				shift
				;;
			--test-report=*)
				_arg_test_report="${_key##--test-report=}"
				;;
			--lint-config)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_lint_config="$2"
				shift
				;;
			--lint-config=*)
				_arg_lint_config="${_key##--lint-config=}"
				;;
			--lint-report)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_lint_report="$2"
				shift
				;;
			--lint-report=*)
				_arg_lint_report="${_key##--lint-report=}"
				;;
			-z|--package-name)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_package_name="$2"
				shift
				;;
			--package-name=*)
				_arg_package_name="${_key##--package-name=}"
				;;
			-z*)
				_arg_package_name="${_key##-z}"
				;;
			-t|--package-target)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_package_target="$2"
				shift
				;;
			--package-target=*)
				_arg_package_target="${_key##--package-target=}"
				;;
			-t*)
				_arg_package_target="${_key##-t}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


handle_passed_args_count ()
{
	_required_args_string="'commands'"
	test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_commands' )
	_our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names+=("_arg_commands[$((ii + 1))]")
	done

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


set -e

clean() {
	echo "Running clean command"
	pipenv --rm | true
}

init() {
	MSG="Running init command"
	ARGS=""

	DEV_DEPS=$1
	if [ "${DEV_DEPS}" == "on" ]; then
		MSG="$MSG including development dependencies"
		ARGS="$ARGS -d"
	fi

	echo "${MSG}"
	pipenv install ${ARGS}
}

test() {
	MSG="Running test command"
	ARGS=""

	TESTS_SELECTOR=$1
	if [ -n "${TESTS_SELECTOR}" ]; then
		MSG="$MSG with selector \"${TESTS_SELECTOR}\""
		ARGS="$ARGS -m \"${TESTS_SELECTOR}\""
	fi

	TEST_REPORT=$2
	if [ "${TEST_REPORT}" == "on" ]; then
		TEST_REPORT_PATH=$3
		if [ -n "${TEST_REPORT_PATH}" ]; then
			MSG="$MSG with reporting enabled (file: ${TEST_REPORT_PATH})"
			ARGS="$ARGS --junitxml=${TEST_REPORT_PATH}"
		fi
	fi

	echo "${MSG}"
	eval "pipenv run python -m pytest ${ARGS}"
}

lint() {
	MSG="Running lint command"
	ARGS=""

	ERRORS_ONLY=$1
	if [ "${ERRORS_ONLY}" == "on" ]; then
		MSG="$MSG checking for errors only"
		ARGS="$ARGS -E"
	fi

	LINT_CONFIG_PATH=$2
	if [ -n "${LINT_CONFIG_PATH}" ]; then
		MSG="$MSG (using lint config file: ${LINT_CONFIG_PATH})"
		ARGS="$ARGS --rcfile=${LINT_CONFIG_PATH}"
	fi

	LINT_REPORT=$3
	if [ "${LINT_REPORT}" == "on" ]; then
		LINT_REPORT_PATH=$4
		if [ -n "${LINT_REPORT_PATH}" ]; then
			MSG="$MSG with reporting enabled (file: ${LINT_REPORT_PATH})"
			ARGS="$ARGS -f parseable"
			OUTPUT="${LINT_REPORT_PATH}"
		fi
	else
		OUTPUT="/dev/null"
	fi

	echo "${MSG}"
	pipenv run python -m pylint ${ARGS} `find . -type f -name "*.py" | sort | tr '\n' ' '` |& tee ${OUTPUT}
}

package() {
	PACKAGE_NAME=$1
	if [ -n "${PACKAGE_NAME}" ]; then
		FILE_NAME="${PACKAGE_NAME}"
	else
		FILE_NAME="${PWD##*/}"
	fi

	PACKAGE_TARGET=$2
	if [ -n "${PACKAGE_TARGET}" ]; then
		TMP_PATH="${PACKAGE_TARGET}"
	fi

	echo "Packaging as ${FILE_NAME}"

	rm -f ${TMP_PATH}/${FILE_NAME}.zip

	zip -q -r ${TMP_PATH}/${FILE_NAME}.zip * --exclude '*/__pycache__/*' '*/.*' 'test/*' '*/test/*' 'tests/*' '*/tests/*'

	cd `pipenv run python -c 'import sys; print(sys.path[-1])'`
	zip -q -r ${TMP_PATH}/${FILE_NAME}.zip . --exclude '*/__pycache__/*'

	echo "Package ${FILE_NAME} zip file available at ${TMP_PATH}/${FILE_NAME}.zip"
}

PROJECT_DIR="${_arg_project}"
if [ ! -d "${PROJECT_DIR}" ]; then
	echo "Directory not found at ${PROJECT_DIR}"
	exit 1
fi

cd "${PROJECT_DIR}"
BASE_PATH=`pwd`
if [ ! -f "Pipfile" ]; then
	echo "Pipfile not found at ${BASE_PATH}/Pipfile"
	exit 1
fi

echo "Running commands for project at ${BASE_PATH}"

for command in "${_arg_commands[@]}"
do
	case "${command}" in
			clean)
	            clean
	            ;;

			init)
	            init "${_arg_dev}"
	            ;;

			test)
	            test "${_arg_tests_selector}" "${_arg_report}" "${_arg_test_report}"
	            ;;

	        lint)
	            lint "${_arg_errors}" "${_arg_lint_config}" "${_arg_report}" "${_arg_lint_report}"
	            ;;

	        package)
				package "${_arg_package_name}" "${_arg_package_target}"
				;;

	        *)
	            echo "Unrecognized command $command"
	            print_help
	            exit 1

	esac
done


# ] <-- needed because of Argbash
